// point10.cpp
// Test point10 stuff
//

#include "common/common.hpp"
#include "compressor.hpp"
#include "decompressor.hpp"

#include "las.hpp"
#include "encoder.hpp"
#include "decoder.hpp"
#include "formats.hpp"

#include <iostream>
#include <memory>

// First, create a simple class to capture data generated by the compressor, this could be anything
// as long as it confirms with the behaviour below.
//
struct SuchStream
{
	SuchStream() : buf(), idx(0)
	{}

	void putBytes(const unsigned char *b, size_t len)
	{
		while (len--)
		{
			buf.push_back(*b++);
		}
	}

	void putByte(const unsigned char b)
	{
		buf.push_back(b);
	}

	unsigned char getByte()
	{
		return buf[idx++];
	}

	void getBytes(unsigned char *b, int len)
	{
		for (int i = 0; i < len; i++)
		{
			b[i] = getByte();
		}
	}

	std::vector<unsigned char> buf;    // cuz I'm ze faste
	size_t idx;
};


int main_point10()
{
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;

	laszip::formats::las::point10 p; // free init to zero :)

	// Create a record compressor for point10
	//
	record_compressor<
			field<las::point10>
	> compressor;

	int N = 9;
	int S = 0;
	// Create an object of our stream to which the encoder will write
	//
	SuchStream s;

	// Instantiate the arithmetic encoder
	//
	encoders::arithmetic<SuchStream> encoder(s);

	// Encode some dummy data
	//
	std::cout << "===========Compression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";

		p.x = i;
		p.y = i + 1000;
		p.z = i + 10000;

		p.intensity = (unsigned short) (i + (1 << 15));
		p.return_number = (i >> 3) & 0x7;
		p.number_of_returns_of_given_pulse = i & 0x7;
		p.scan_direction_flag = i & 1;
		p.edge_of_flight_line = (i + 1) & 1;
		p.classification = (unsigned char) i % 256;
		p.scan_angle_rank = (unsigned char) i % 128;
		p.user_data = (i >> 4) % 256;
		p.point_source_ID = (i * 30) % (1 << 16);

		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor.compressWith(encoder, (const char *) &p);
	}

	// Finally terminate the encoder by calling done on it. This will flush out any pending data to output.
	//
	encoder.done();


	// Print some fun stuff about compression
	//
	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;
	//return 0;


	// Setup record decompressor for point10
	//
	record_decompressor<
			field<las::point10>
	> decompressor;

	// Create a decoder same way as we did with the encoder
	//
	decoders::arithmetic<SuchStream> decoder(s);

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	std::cout << "===========Deompression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";
		// When we decompress data we need to provide where to decode stuff to
		//
		las::point10 p2;
		decompressor.decompressWith(decoder, (char *) &p2);

		// Finally make sure things match, otherwise bail
		if (p2.x != i ||
		    p2.y != i + 1000 ||
		    p2.z != i + 10000 ||
		    p2.intensity != (unsigned short) (i + (1 << 15)) ||
		    p2.return_number != ((i >> 3) & 0x7) ||
		    p2.number_of_returns_of_given_pulse != (i & 0x7) ||
		    p2.scan_direction_flag != (i & 1) ||
		    p2.edge_of_flight_line != ((i + 1) & 1) ||
		    p2.classification != ((unsigned char) i % 256) ||
		    p2.scan_angle_rank != ((unsigned char) i % 128) ||
		    p2.user_data != ((i >> 4) % 256) ||
		    p2.point_source_ID != ((i * 30) % (1 << 16)))
			throw std::runtime_error("Not matching");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}

int main_rgb()
{
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;


	// Create a record compressor for point10
	//
	record_compressor<
			field<las::rgb>
	> compressor;

	int N = 120;
	int S = 0;
	// Create an object of our stream to which the encoder will write
	//
	SuchStream s;

	// Instantiate the arithmetic encoder
	//
	encoders::arithmetic<SuchStream> encoder(s);
	las::rgb rgb;

	// Encode some dummy data
	//
	std::cout << "===========Compression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";
		rgb.r = (i + 1000) % 65535;
		rgb.g = (i + 5000) % 65535;
		rgb.b = (i + 10000) % 65535;

		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor.compressWith(encoder, (const char *) &rgb);
	}

	// Finally terminate the encoder by calling done on it. This will flush out any pending data to output.
	//
	encoder.done();


	// Print some fun stuff about compression
	//
	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;
//	return 0;


	// Setup record decompressor for point10
	//
	record_decompressor<
			field<las::rgb>
	> decompressor;

	// Create a decoder same way as we did with the encoder
	//
	decoders::arithmetic<SuchStream> decoder(s);

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	std::cout << "===========Deompression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";
		// When we decompress data we need to provide where to decode stuff to
		//
		las::rgb rgb;
		decompressor.decompressWith(decoder, (char *) &rgb);

		// Finally make sure things match, otherwise bail
		if (rgb.r != (i + 1000) % 65535 ||
		    rgb.g != (i + 5000) % 65535 ||
		    rgb.b != (i + 10000) % 65535)
			throw std::runtime_error("Not matching");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}



int main_gps()
{
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;


	// Create a record compressor for point10
	//
	record_compressor<
			field<las::gpstime>
	> compressor;

	int N = 2;
	int S = 0;
	// Create an object of our stream to which the encoder will write
	//
	SuchStream s;

	// Instantiate the arithmetic encoder
	//
	encoders::arithmetic<SuchStream> encoder(s);

	// Encode some dummy data
	//
	std::cout << "===========Compression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";
		las::gpstime gpstime{static_cast<int64_t>((i + 48741) % std::numeric_limits<uint64_t >::max())};
		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor.compressWith(encoder, (const char *) &gpstime.value);
	}

	// Finally terminate the encoder by calling done on it. This will flush out any pending data to output.
	//
	encoder.done();


	// Print some fun stuff about compression
	//
	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;
//	return 0;


	// Setup record decompressor for point10
	//
	record_decompressor<
			field<las::gpstime>
	> decompressor;

	// Create a decoder same way as we did with the encoder
	//
	decoders::arithmetic<SuchStream> decoder(s);

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	std::cout << "===========Deompression Starts==================\n";
	for (int i = S; i < N; i++)
	{
		std::cout << "=== " << i << " ===\n";
		// When we decompress data we need to provide where to decode stuff to
		//
		las::gpstime gpstime;
		decompressor.decompressWith(decoder, (char *) &gpstime.value);

		// Finally make sure things match, otherwise bail
		if (gpstime.value != (i + 48741) % std::numeric_limits<uint64_t >::max())
			throw std::runtime_error("Not matching");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}

int main() {
	try {
		main_gps();
	} catch (const std::exception & e) {
		std::cout << "ERROR: " << e.what() << '\n';
	}
}