// dynamic.cpp
// Do some dynamic record stuff
//

#include "common/common.hpp"
#include "compressor.hpp"
#include "decompressor.hpp"

#include "encoder.hpp"
#include "decoder.hpp"
#include "formats.hpp"
#include "las.hpp"

#include <iostream>
#include <memory>

// First, create a simple class to capture data generated by the compressor, this could be anything
// as long as it confirms with the behaviour below.
//
struct SuchStream
{
	SuchStream() : buf(), idx(0)
	{}

	void putBytes(const unsigned char *b, size_t len)
	{
		while (len--)
		{
			buf.push_back(*b++);
		}
	}

	void putByte(const unsigned char b)
	{
		buf.push_back(b);
	}

	unsigned char getByte()
	{
		return buf[idx++];
	}

	void getBytes(unsigned char *b, int len)
	{
		for (int i = 0; i < len; i++)
		{
			b[i] = getByte();
		}
	}

	std::vector<unsigned char> buf;    // cuz I'm ze faste
	size_t idx;
};

int main2() {
    // import namespaces to reduce typing
    //
    using namespace laszip;
    using namespace laszip::formats;

	typedef encoders::arithmetic<SuchStream> EncoderType;
	typedef decoders::arithmetic<SuchStream> DecoderType;

	// Get a memory stream backed encoder up
	SuchStream s;
	EncoderType encoder(s);
	int num_points = 0;


	auto compressor = make_dynamic_compressor(encoder);
	compressor->add_field<int>();

/*
	// Encode some dummy data
	//
	for (int i = 0; i < num_points; i++)
	{
		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor->compress((const char *) &i);
	}
*/

	char a[4] = {1,2,3,4};
	compressor->compress(a);
	encoder.done();

	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;
	int i = 0;
	for (auto m : s.buf)
	{
		std::cout << static_cast<int>(m) << ' ';
		i++;
		if (i == 4) {
			i = 0;
			std::cout << '\n';
		}
	}

	DecoderType decoder(s);

	// Print some fun stuff about compression
	//

	auto decompressor = make_dynamic_decompressor(decoder);
	decompressor->add_field<int>();

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	for (int i = 0; i < num_points; i++)
	{
		// When we decompress data we need to provide where to decode stuff to

		int a;
		decompressor->decompress((char *) &a);

		// Finally make sure things match, otherwise bail
		if (a != i)
			throw std::runtime_error("I have failed thee!");
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}

int main() {
	// import namespaces to reduce typing
	//
	using namespace laszip;
	using namespace laszip::formats;

	typedef encoders::arithmetic<SuchStream> EncoderType;
	typedef decoders::arithmetic<SuchStream> DecoderType;

	size_t num_elements = 21;

	// Get a memory stream backed encoder up
	SuchStream s;
	EncoderType encoder(s);


	auto compressor = make_dynamic_compressor(encoder);
	compressor->add_field<int>();



	// Encode some dummy data
	//
	for (int i = 0 ; i < num_elements; i ++) {
		std::cout << "=== " << i << " ===\n";
		int mdr = i;
		const char *p = (const char*)&mdr;
		std::cout << "[" << static_cast<int>(p[0]) << ", " << static_cast<int>(p[1]) << ", "<< static_cast<int>(p[2]) << ", "<< static_cast<int>(p[3]) << "]\n";
		// All compressor cares about is your data as a pointer, it will unpack data
		// automatically based on the fields that were specified and compress them
		//
		compressor->compress((const char*)&mdr);
	}

	encoder.done();

	std::cout << "Points compressed to: " << s.buf.size() << " bytes" << std::endl;

	std::cout << "==============================Decompression=======================\n";

	DecoderType decoder(s);

	// Print some fun stuff about compression
	//

	auto decompressor = make_dynamic_decompressor(decoder);
	decompressor->add_field<int>();

	// This time we'd read the values out instead and make sure they match what we pushed in
	//
	for (int i = 0 ; i < num_elements ; i ++) {
		std::cout << "=== " << i << " ===\n";
		// When we decompress data we need to provide where to decode stuff to
		//
		int mdr;
		decompressor->decompress((char *)&mdr);

		// Finally make sure things match, otherwise bail
		if (mdr != i)
			throw std::runtime_error("I have failed thee!");

		std::cout << '\n';
	}

	// And we're done
	std::cout << "Done!" << std::endl;

	return 0;
}
